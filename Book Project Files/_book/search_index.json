[
["index.html", "tidyverse Book 1 Preface", " tidyverse Book CUNY SPS DATA 607 Spring 2018 2018-05-06 1 Preface Testing the bibliography below… To create an inline reference use square brackets and @R- followed by the package name. For example: (Wickham and Henry 2018) The reference will show at the bottom of the page and also at the end in the references chapter. References "],
["intro.html", "2 Introduction 2.1 Core tidyverse", " 2 Introduction 2.1 Core tidyverse Some quotes and concepts from Hadley Wickham that we may want to include in the intro… 2.1.0.1 Data semantics A dataset is a collection of values, usually either numbers (if quantitative) or strings (if qualitative). Values are organised in two ways. Every value belongs to a variable and an observation. A variable contains all values that measure the same underlying attribute (like height, temperature, duration) across units. An observation contains all values measured on the same unit (like a person, or a day, or a race) across attributes. The experimental design also determines whether or not missing values can be safely dropped. In this experiment, the missing value represents an observation that should have been made, but wasn’t, so it’s important to keep it. Structural missing values, which represent measurements that can’t be made (e.g., the count of pregnant males) can be safely removed. A general rule of thumb is that it is easier to describe functional relationships between variables (e.g., z is a linear combination of x and y, density is the ratio of weight to volume) than between rows, and it is easier to make comparisons between groups of observations (e.g., average of group a vs. average of group b) than between groups of columns. 2.1.0.2 Tidy data Tidy data is a standard way of mapping the meaning of a dataset to its structure. A dataset is messy or tidy depending on how rows, columns and tables are matched up with observations, variables and types. In tidy data: 1. Each variable forms a column. 2. Each observation forms a row. 3. Each type of observational unit forms a table. This is Codd’s 3rd normal form, but with the constraints framed in statistical language, and the focus put on a single dataset rather than the many connected datasets common in relational databases. Messy data is any other arrangement of the data. Alternate Definition from Garrett Grolemund R follows a set of conventions that makes one layout of tabular data much easier to work with than others. Your data will be easier to work with in R if it follows three rules 1. Each variable in the data set is placed in its own column 2. Each observation is placed in its own row 3. Each value is placed in its own cell* Data that satisfies these rules is known as tidy data. five most common problems with messy datasets…: 1. Column headers are values, not variable names. 2. Multiple variables are stored in one column. 3. Variables are stored in both rows and columns. 4. Multiple types of observational units are stored in the same table. 5. A single observational unit is stored in multiple tables. 2.1.0.3 Normalization Normalisation is useful for tidying and eliminating inconsistencies. However, there are few data analysis tools that work directly with relational data, so analysis usually also requires denormalisation or the merging the datasets back into one table. "],
["ggplot2.html", "3 ggplot2 3.1 +.gg () 3.2 aes () 3.3 aes_ () 3.4 aes_colour_fill_alpha () 3.5 aes_group_order () 3.6 aes_linetype_size_shape () 3.7 aes_position () 3.8 annotate () 3.9 annotation_custom () 3.10 annotation_logticks () 3.11 annotation_map () 3.12 annotation_raster () 3.13 autoplot () 3.14 borders () 3.15 coord_cartesian () 3.16 coord_fixed () 3.17 coord_flip () 3.18 coord_map () 3.19 coord_polar () 3.20 coord_trans () 3.21 cut_interval () 3.22 diamonds () 3.23 economics () 3.24 expand_limits () 3.25 facet_grid () 3.26 facet_wrap () 3.27 faithfuld () 3.28 fortify () 3.29 geom_abline () 3.30 geom_bar () 3.31 geom_bin2d () 3.32 geom_blank () 3.33 geom_boxplot () 3.34 geom_contour () 3.35 geom_count () 3.36 geom_crossbar () 3.37 geom_density () 3.38 geom_density_2d () 3.39 geom_dotplot () 3.40 geom_errorbarh () 3.41 geom_freqpoly () 3.42 geom_hex () 3.43 geom_jitter () 3.44 geom_label () 3.45 geom_map () 3.46 geom_path () 3.47 geom_point () 3.48 geom_polygon () 3.49 geom_qq () 3.50 geom_quantile () 3.51 geom_raster () 3.52 geom_ribbon () 3.53 geom_rug () 3.54 geom_segment () 3.55 geom_smooth () 3.56 geom_spoke () 3.57 geom_violin () 3.58 ggplot () 3.59 ggproto () 3.60 ggsave () 3.61 ggtheme () 3.62 guides () 3.63 guide_colourbar () 3.64 guide_legend () 3.65 hmisc () 3.66 labeller () 3.67 labellers () 3.68 label_bquote () 3.69 labs () 3.70 lims () 3.71 luv_colours () 3.72 margin () 3.73 mean_se () 3.74 midwest () 3.75 mpg () 3.76 msleep () 3.77 position_dodge () 3.78 position_identity () 3.79 position_jitter () 3.80 position_jitterdodge () 3.81 position_nudge () 3.82 position_stack () 3.83 presidential () 3.84 print.ggplot () 3.85 print.ggproto () 3.86 qplot () 3.87 resolution () 3.88 scale_alpha () 3.89 scale_colour_brewer () 3.90 scale_colour_gradient () 3.91 scale_colour_grey () 3.92 scale_colour_hue () 3.93 scale_continuous () 3.94 scale_date () 3.95 scale_identity () 3.96 scale_linetype () 3.97 scale_manual () 3.98 scale_shape () 3.99 scale_size () 3.100 scale_x_discrete () 3.101 seals () 3.102 sec_axis () 3.103 stat_ecdf () 3.104 stat_ellipse () 3.105 stat_function () 3.106 stat_identity () 3.107 stat_summary_2d () 3.108 stat_summary_bin () 3.109 stat_unique () 3.110 theme () 3.111 theme_get () 3.112 txhousing () 3.113 rename() 3.114 filter() 3.115 arrange() 3.116 mutate() and transmute() 3.117 summarise() 3.118 sample_n() and sample_frac() 3.119 scored operations", " 3 ggplot2 3.1 +.gg () 3.2 aes () 3.3 aes_ () 3.4 aes_colour_fill_alpha () 3.5 aes_group_order () 3.6 aes_linetype_size_shape () 3.7 aes_position () 3.8 annotate () 3.9 annotation_custom () 3.10 annotation_logticks () 3.11 annotation_map () 3.12 annotation_raster () 3.13 autoplot () 3.14 borders () 3.15 coord_cartesian () 3.16 coord_fixed () 3.17 coord_flip () 3.18 coord_map () 3.19 coord_polar () 3.20 coord_trans () 3.21 cut_interval () 3.22 diamonds () 3.23 economics () 3.24 expand_limits () 3.25 facet_grid () 3.26 facet_wrap () 3.27 faithfuld () 3.28 fortify () 3.29 geom_abline () 3.30 geom_bar () 3.31 geom_bin2d () 3.32 geom_blank () 3.33 geom_boxplot () 3.34 geom_contour () 3.35 geom_count () 3.36 geom_crossbar () 3.37 geom_density () 3.38 geom_density_2d () 3.39 geom_dotplot () 3.40 geom_errorbarh () 3.41 geom_freqpoly () 3.42 geom_hex () 3.43 geom_jitter () 3.44 geom_label () 3.45 geom_map () 3.46 geom_path () 3.47 geom_point () 3.48 geom_polygon () 3.49 geom_qq () 3.50 geom_quantile () 3.51 geom_raster () 3.52 geom_ribbon () 3.53 geom_rug () 3.54 geom_segment () 3.55 geom_smooth () 3.56 geom_spoke () 3.57 geom_violin () 3.58 ggplot () 3.59 ggproto () 3.60 ggsave () 3.61 ggtheme () 3.62 guides () 3.63 guide_colourbar () 3.64 guide_legend () 3.65 hmisc () 3.66 labeller () 3.67 labellers () 3.68 label_bquote () 3.69 labs () 3.70 lims () 3.71 luv_colours () 3.72 margin () 3.73 mean_se () 3.74 midwest () 3.75 mpg () 3.76 msleep () 3.77 position_dodge () 3.78 position_identity () 3.79 position_jitter () 3.80 position_jitterdodge () 3.81 position_nudge () 3.82 position_stack () 3.83 presidential () 3.84 print.ggplot () 3.85 print.ggproto () 3.86 qplot () 3.87 resolution () 3.88 scale_alpha () 3.89 scale_colour_brewer () 3.90 scale_colour_gradient () 3.91 scale_colour_grey () 3.92 scale_colour_hue () 3.93 scale_continuous () 3.94 scale_date () 3.95 scale_identity () 3.96 scale_linetype () 3.97 scale_manual () This recipe is available including rendered plots as an Rpubs here: http://rpubs.com/hmgeiger/384663 This Github contains just the code for now, not including rendered plots. Read in a CSV file with survey data about Thanksgiving. More info available here: https://github.com/fivethirtyeight/data/tree/master/thanksgiving-2015 csv_link &lt;- &quot;https://raw.githubusercontent.com/fivethirtyeight/data/master/thanksgiving-2015/thanksgiving-2015-poll-data.csv&quot; thanksgiving &lt;- read.csv(csv_link,header=TRUE,stringsAsFactors=FALSE,check.names=FALSE) Filter only for individuals that celebrate Thanksgiving, after cleaning up some column names. colnames(thanksgiving)[2] &lt;- &quot;Celebrates_Thanksgiving&quot; colnames(thanksgiving)[c(25,38,50)] &lt;- c(&quot;Which of these side dishes aretypically served at your Thanksgiving dinner? Please select all that apply. - Other (please specify again)&quot;, &quot;Which type of pie is typically served at your Thanksgiving dinner? Please select all that apply. - Other (please specify again)&quot;, &quot;Which of these desserts do you typically have at Thanksgiving dinner? Please select all that apply. - Other (please specify again)&quot;) thanksgiving &lt;- thanksgiving %&gt;% filter(Celebrates_Thanksgiving == &quot;Yes&quot;) Select columns corresponding to side dishes, minus “Other”. Then, count number of people who selected each side. side_dish_columns &lt;- grep(&#39;Which of these side dishes aretypically served at your Thanksgiving dinner?&#39;,colnames(thanksgiving),value=TRUE) side_dish_columns &lt;- side_dish_columns[grep(&#39;Other&#39;,side_dish_columns,invert=TRUE)] side_dish_frequency &lt;- data.frame(Side = rep(NA,times=length(side_dish_columns)), Frequency = rep(NA,times=length(side_dish_columns))) for(i in 1:length(side_dish_columns)) { side_name &lt;- str_replace_all(side_dish_columns[i], pattern=&#39;Which of these side dishes aretypically served at your Thanksgiving dinner\\\\? Please select all that apply\\\\. - &#39;, replace=&#39;&#39;) side_dish_frequency[i,] &lt;- c(side_name,length(which(thanksgiving[,side_dish_columns[i]] != &quot;&quot;))) } side_dish_frequency$Frequency &lt;- as.numeric(side_dish_frequency$Frequency) Make a barplot of the frequency of different sides, minus “Other”. ggplot(side_dish_frequency,aes(Side,Frequency)) + geom_bar(stat=&quot;identity&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) Now use scale_fill_manual to color each bar by a color appropriate to the food. Use colors here as a guide: http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf Put in colors based on order sides appear in side_dish_frequency. Let’s color fruit salad as red, since may have watermelon, strawberry, etc. ggplot(side_dish_frequency,aes(Side,Frequency,fill=Side)) + geom_bar(stat=&quot;identity&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_fill_manual(values = c(&quot;darkgreen&quot;,&quot;darkorange&quot;,&quot;floralwhite&quot;,&quot;gold&quot;,&quot;gold&quot;,&quot;firebrick1&quot;,&quot;darkgreen&quot;,&quot;gold&quot;,&quot;floralwhite&quot;,&quot;floralwhite&quot;,&quot;darkorange&quot;,&quot;darkgreen&quot;,&quot;darkorange&quot;)) Sort by frequency, then adjust the order of the color vector accordingly. color_per_side &lt;- c(&quot;darkgreen&quot;,&quot;darkorange&quot;,&quot;floralwhite&quot;,&quot;gold&quot;,&quot;gold&quot;,&quot;firebrick1&quot;,&quot;darkgreen&quot;,&quot;gold&quot;,&quot;floralwhite&quot;,&quot;floralwhite&quot;,&quot;darkorange&quot;,&quot;darkgreen&quot;,&quot;darkorange&quot;) color_per_side &lt;- color_per_side[order(side_dish_frequency$Frequency)] side_dish_frequency$Side &lt;- factor(side_dish_frequency$Side, levels=side_dish_frequency$Side[order(side_dish_frequency$Frequency)]) ggplot(side_dish_frequency, aes(Side,Frequency,fill=Side)) + geom_bar(stat=&quot;identity&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_fill_manual(values = color_per_side) We find that the two most popular Thanksgiving sides are both white. What if we use shape_colour_manual instead, and specify color by side instead of fill by side? ggplot(side_dish_frequency, aes(Side,Frequency,colour=Side)) + geom_bar(stat=&quot;identity&quot;,fill=&quot;lightgrey&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_colour_manual(values = color_per_side) Now the color of the border of the bars will change based on the colors we have specified. Using “colour” instead of “fill” probably isn’t what we want for a barplot. But it might be useful for other types of plots (like scatterplots with a hollow dot for the points). 3.98 scale_shape () 3.99 scale_size () 3.100 scale_x_discrete () 3.101 seals () 3.102 sec_axis () 3.103 stat_ecdf () 3.104 stat_ellipse () 3.105 stat_function () 3.106 stat_identity () 3.107 stat_summary_2d () 3.108 stat_summary_bin () 3.109 stat_unique () 3.110 theme () 3.111 theme_get () 3.112 txhousing () There is a complement to the ggplot2 function - ggiraph. Ggiraph allows the user to turn their normal ggplot graphs into interactive graphics. Some usage of the ggiraph functions are: geom_bar_interactive geom_boxplot_interactive geom_histogram_interactive geom_line_interactive geom_map_interactive geom_path_interactive geom_point_interactive geom_polygon_interactive geom_rect_interactive geom_segment_interactive geom_text_interactive geom_tile_interactive The ggiraph package lets you add more aesthetics to your ggplot graph. tooltip: column of dataset that contains tooltips to be displayed when mouse is over elements. data_id: column of dataset that contains id to be associated with elements The ggiraph function is called using library(ggiraph). Tooltips Tooltips can be created using the following example: r # Need to debug and get rid of eval=FALSE above once working library(tidyverse) library(ggiraph) library(fueleconomy) ```r # Need to debug and get rid of eval=FALSE above once working ggexample &lt;- ggplot(vehicles, aes(factor(vehicles\\(year), vehicles\\)hwy)) + geom_boxplot_interactive(aes(tooltip = year)) ggiraph(code = print(ggexample)) ``` When the users mouse hovers over an item, the tooltip will be displayed - in this case “Year”. Hover effects can be created using the following example: ```r # Need to debug and get rid of eval=FALSE above once working ggexample &lt;- ggplot(vehicles, aes(factor(vehicles\\(year), vehicles\\)hwy, color = hwy)) + geom_boxplot_interactive(aes(tooltip = year, data_id = year)) ggiraph(code = print(ggexample)) ``` As you can see in the example above, the boxs change color on when the users mouse hovers over the item. More information can be found here: http://rpubs.com/nschettini/386363 # dplyr {#dplyr} dplyr provides a grammar of data manipulation, providing a consistent set of verbs that solve the most common data manipulation challenges. ## select() The select function provides options for selecting only certain columns of data to work with. r alcohol.data &lt;- read_csv('https://raw.githubusercontent.com/fivethirtyeight/data/master/alcohol-consumption/drinks.csv') alcohol.data %&gt;% head() %&gt;% kable() country beer_servings spirit_servings wine_servings total_litres_of_pure_alcohol Afghanistan 0 0 0 0.0 Albania 89 132 54 4.9 Algeria 25 0 14 0.7 Andorra 245 138 312 12.4 Angola 217 57 45 5.9 Antigua &amp; Barbuda 102 128 45 4.9 At it’s most basic, select allows for the manual selection of columns alcohol.data %&gt;% select(country, total_litres_of_pure_alcohol) %&gt;% head() %&gt;% kable() country total_litres_of_pure_alcohol Afghanistan 0.0 Albania 4.9 Algeria 0.7 Andorra 12.4 Angola 5.9 Antigua &amp; Barbuda 4.9 alcohol.data %&gt;% select(c(1, 3)) %&gt;% head() %&gt;% kable() country spirit_servings Afghanistan 0 Albania 132 Algeria 0 Andorra 138 Angola 57 Antigua &amp; Barbuda 128 alcohol.data %&gt;% select(1:4) %&gt;% head() %&gt;% kable() country beer_servings spirit_servings wine_servings Afghanistan 0 0 0 Albania 89 132 54 Algeria 25 0 14 Andorra 245 138 312 Angola 217 57 45 Antigua &amp; Barbuda 102 128 45 There are a number of additional functions that can be used to select columns based on specific criteria. These include: starts_with() which selects all columns that begin with the given text ends_with() which selects all columns that end with the given text contains() which selects all columns that contain the given text anywhere matches() which selects all columns that match the given regular expression. See regular expressions for more details. Finally, a dash (-) may be added to the beginning of any of these functions to select all columns that do NOT match. alcohol.data %&gt;% select(-ends_with(&#39;servings&#39;)) %&gt;% head() %&gt;% kable() country total_litres_of_pure_alcohol Afghanistan 0.0 Albania 4.9 Algeria 0.7 Andorra 12.4 Angola 5.9 Antigua &amp; Barbuda 4.9 The select function can also be used to rearrange the columns in a data frame. alcohol.data %&gt;% select(1, 5, 2:4) %&gt;% head() %&gt;% kable() country total_litres_of_pure_alcohol beer_servings spirit_servings wine_servings Afghanistan 0.0 0 0 0 Albania 4.9 89 132 54 Algeria 0.7 25 0 14 Andorra 12.4 245 138 312 Angola 5.9 217 57 45 Antigua &amp; Barbuda 4.9 102 128 45 A special function everything() will select all remaining columns in order. This is best used when you wish to move a single column to a new position but do not care to rearrange the remaining columns. alcohol.data %&gt;% select(1, 5, everything()) %&gt;% head() %&gt;% kable() country total_litres_of_pure_alcohol beer_servings spirit_servings wine_servings Afghanistan 0.0 0 0 0 Albania 4.9 89 132 54 Algeria 0.7 25 0 14 Andorra 12.4 245 138 312 Angola 5.9 217 57 45 Antigua &amp; Barbuda 4.9 102 128 45 Select also has the ability to rename columns, however, it will drop all columns not mentioned. In order to rename columns but to keep all columns (regardless of whether their names have been changed) it is best to use rename(). See rename(). alcohol.data %&gt;% select(location=country, everything()) %&gt;% head() %&gt;% kable() location beer_servings spirit_servings wine_servings total_litres_of_pure_alcohol Afghanistan 0 0 0 0.0 Albania 89 132 54 4.9 Algeria 25 0 14 0.7 Andorra 245 138 312 12.4 Angola 217 57 45 5.9 Antigua &amp; Barbuda 102 128 45 4.9 3.113 rename() The rename function is used to alter the names of columns. Any columns not specified will not be changed. If you wish to drop unnamed columns at the same time, use select() See select(). alcohol.data %&gt;% rename(beer=beer_servings, spirit=spirit_servings, wine=wine_servings) %&gt;% head() %&gt;% kable() country beer spirit wine total_litres_of_pure_alcohol Afghanistan 0 0 0 0.0 Albania 89 132 54 4.9 Algeria 25 0 14 0.7 Andorra 245 138 312 12.4 Angola 217 57 45 5.9 Antigua &amp; Barbuda 102 128 45 4.9 3.114 filter() The filter function allows a user to subset a data frame based on the values in a given column. avengers.data &lt;- read_csv(&#39;https://raw.githubusercontent.com/fivethirtyeight/data/master/avengers/avengers.csv&#39;) %&gt;% select(2:6) avengers.data %&gt;% head() %&gt;% kable() Name/Alias Appearances Current? Gender Probationary Introl Henry Jonathan “Hank” Pym 1269 YES MALE NA Janet van Dyne 1165 YES FEMALE NA Anthony Edward “Tony” Stark 3068 YES MALE NA Robert Bruce Banner 2089 YES MALE NA Thor Odinson 2402 YES MALE NA Richard Milhouse Jones 612 YES MALE NA Perhaps the user would like to work only with the female avengers. avengers.data %&gt;% filter(Gender == &#39;FEMALE&#39;) %&gt;% head() %&gt;% kable() Name/Alias Appearances Current? Gender Probationary Introl Janet van Dyne 1165 YES FEMALE NA Wanda Maximoff 1214 YES FEMALE NA Natalia Alianovna Romanova 1112 YES FEMALE NA Brandt 160 NO FEMALE NA Heather Douglas 332 NO FEMALE Jul-75 Patsy Walker 557 NO FEMALE Nov-75 Perhaps the user would like to work only with female avengers with more than 500 appearances. avengers.data %&gt;% filter(Gender == &#39;FEMALE&#39; &amp; Appearances &gt; 500) %&gt;% head() %&gt;% kable() Name/Alias Appearances Current? Gender Probationary Introl Janet van Dyne 1165 YES FEMALE NA Wanda Maximoff 1214 YES FEMALE NA Natalia Alianovna Romanova 1112 YES FEMALE NA Patsy Walker 557 NO FEMALE Nov-75 Carol Susan Jane Danvers 935 YES FEMALE NA Jennifer Walters 933 YES FEMALE NA There are numerous comparison options that can be used with filter. These include: ==, &gt;, &gt;=, &lt;, &lt;=, != The use of a single ampersand &amp; is used to indicate ‘and’ while a single pipe | is used to indicate ‘or’. The exclamation point ! is used to indicate ‘nor’ (see next example) and xor() is the exclusive or. Filtering can also be based on whether an element is NA. This data set does not have any NAs, but rather has empty strings in cases where the variable does not apply. To demonstrate the technique of filtering out NAs, let’s convert these empty strings to NAs. Then, use the filter function to select cases where the variable is non-NA. # Need to debug and get rid of eval=FALSE above once working avengers.data_incl_NAs &lt;- avengers.data var &lt;- &quot;Probationary Introl&quot; avengers.data_incl_NAs[,var] &lt;- plyr::mapvalues(avengers.data_incl_NAs[,var], from = &quot;&quot;,to=NA) avengers.data_incl_NAs %&gt;% filter(!is.na(`Probationary Introl`)) %&gt;% kable() Between can be used to filter between a range of values. avengers.data %&gt;% filter(between(Appearances, 500, 1000)) %&gt;% head() %&gt;% kable() Name/Alias Appearances Current? Gender Probationary Introl Richard Milhouse Jones 612 YES MALE NA Pietro Maximoff 769 YES MALE NA Heracles 741 YES MALE NA T’Challa 780 NO MALE NA Patsy Walker 557 NO FEMALE Nov-75 Simon Williams 692 YES MALE Apr-77 Finally, near can be used to select a range of values within a certain range of a central value. avengers.data %&gt;% filter(near(Appearances, 612, tol=20)) %&gt;% head() %&gt;% kable() Name/Alias Appearances Current? Gender Probationary Introl Richard Milhouse Jones 612 YES MALE NA Daniel Thomas Rand K’ai 629 NO MALE NA Of course, all of these can be combined with ‘and’ &amp; and ‘or’ | logical operators. There are three related functions filter_if(), filter_all(), and filter_at(). See scoped operations. For a last example, let’s combine the and operator with the or operator to choose results meeting two mutually exclusive criteria, each based on two different conditions. high_appearance_females &lt;- avengers.data %&gt;% filter(Gender == &quot;FEMALE&quot; &amp; Appearances &gt; 500) low_appearance_males &lt;- avengers.data %&gt;% filter(Gender == &quot;MALE&quot; &amp; Appearances &lt; 200) high_appearance_females_or_low_appearance_males &lt;- avengers.data %&gt;% filter((Gender == &quot;FEMALE&quot; &amp; Appearances &gt; 500) | (Gender == &quot;MALE&quot; &amp; Appearances &lt; 200)) nrow(high_appearance_females) ## [1] 10 nrow(low_appearance_males) ## [1] 65 nrow(high_appearance_females_or_low_appearance_males) ## [1] 75 There are 10 high appearance females and 65 low appearance males. Thus, the fact that we get 75 results for the query using OR operator makes sense, as the criteria we looked for using the OR operator are mutually exclusive. 3.115 arrange() arrange changes the natural column order of the data frame. It takes data frame name and the column name(s) as input and re arranges the columns based on input. 3.116 mutate() and transmute() 3.117 summarise() 3.118 sample_n() and sample_frac() 3.119 scored operations "],
["tidyr.html", "4 tidyr 4.1 complete () 4.2 drop_na () 4.3 expand () 4.4 extract () 4.5 fill () 4.6 full_seq () 4.7 gather () 4.8 nest () 4.9 replace_na () 4.10 separate () 4.11 separate_rows () 4.12 smiths () 4.13 spread () 4.14 table1 () 4.15 uncount () 4.16 unite () 4.17 unnest () 4.18 who ()", " 4 tidyr 4.1 complete () 4.2 drop_na () 4.3 expand () 4.4 extract () 4.5 fill () 4.6 full_seq () 4.7 gather () 4.8 nest () 4.9 replace_na () 4.10 separate () 4.11 separate_rows () 4.12 smiths () 4.13 spread () 4.14 table1 () 4.15 uncount () 4.16 unite () 4.17 unnest () 4.18 who () "],
["readr.html", "5 readr 5.1 read_csv() 5.2 cols () 5.3 cols_condense () 5.4 col_skip () 5.5 count_fields () 5.6 date_names () 5.7 format_delim () 5.8 guess_encoding () 5.9 locale () 5.10 parse_atomic () 5.11 parse_datetime (), parse_date() and parse_time() 5.12 parse_factor () 5.13 parse_logical(), parse_number(), parse_double() and parse_integer() 5.14 parse_character() 5.15 parse_guess () 5.16 problems () 5.17 read_delim () 5.18 read_file () 5.19 read_fwf () 5.20 read_lines () 5.21 read_log () 5.22 read_table () 5.23 spec_delim () 5.24 type_convert () 5.25 write_delim ()", " 5 readr library(tidyverse) library(hms) 5.1 read_csv() read_csv() - Reads comma-delimited files read_csv2() - Reads semicolon-separated files read_tsv() - Reads tab-delimited files read_delim() - Reads in files with any delimiter Read file will print out a column specification that gives the name and type of each column: # Need to debug and get rid of eval=FALSE above once working data &lt;- read_csv(&quot;data/example.csv&quot;) read_csv() uses the first line of the data for the column names, the following examples will show how to tweak this behavior: Using skip = n (n is the number of lines to skip) read_csv(&quot;This the first line This is the second line a,b,c 1,2,3&quot;, skip = 2) ## # A tibble: 1 x 3 ## a b c ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 2 3 Using comment = “#” to skip all lines that starts with “#” read_csv(&quot;# This is a comment line a,b,c 1,2,3&quot;, comment = &quot;#&quot;) ## # A tibble: 1 x 3 ## a b c ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 2 3 If there’s no column names, using col_names = FALSE read_csv(&quot;1,2,3 4,5,6&quot;, col_names = FALSE) ## # A tibble: 2 x 3 ## X1 X2 X3 ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 2 3 ## 2 4 5 6 If there’s column names read_csv(&quot;1,2,3 4,5,6&quot;, col_names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## # A tibble: 2 x 3 ## a b c ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 2 3 ## 2 4 5 6 5.2 cols () 5.3 cols_condense () 5.4 col_skip () 5.5 count_fields () 5.6 date_names () 5.7 format_delim () 5.8 guess_encoding () To find the types of encoding: guess_encoding(charToRaw(&quot;Data Analytics&quot;)) ## # A tibble: 1 x 2 ## encoding confidence ## &lt;chr&gt; &lt;dbl&gt; ## 1 ASCII 1. 5.9 locale () The goal of readr’s locales is to encapsulate common options that vary between languages and localities. This includes: - The names of months and days, used when parsing dates. - The default time zone, used when parsing datetimes. - The character encoding, used when reading non-ASCII strings. - Default date format, used when guessing column types. - The decimal and grouping marks, used when reading numbers. 5.10 parse_atomic () 5.11 parse_datetime (), parse_date() and parse_time() Allow to parse varoious date and time specifications. str(parse_date(c(&quot;2018-05-01&quot;, &quot;2018-04-30&quot;))) ## Date[1:2], format: &quot;2018-05-01&quot; &quot;2018-04-30&quot; parse_time(c(&quot;6:43 pm&quot;)) ## 18:43:00 5.12 parse_factor () Creates factors, the data structure that R uses to represent categorical variables with fixed and known values. parse_factor(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), levels = c(&quot;a&quot;, &quot;b&quot;)) ## Warning: 1 parsing failure. ## row # A tibble: 1 x 4 col row col expected actual expected &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; actual 1 3 NA value in level set c ## [1] a b &lt;NA&gt; ## attr(,&quot;problems&quot;) ## # A tibble: 1 x 4 ## row col expected actual ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 3 NA value in level set c ## Levels: a b 5.13 parse_logical(), parse_number(), parse_double() and parse_integer() Parse logicals, numbers, doubles and integers respectively. str(parse_logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;NA&quot;))) ## logi [1:3] TRUE FALSE NA parse_number(&quot;$112,33&quot;) ## [1] 11233 parse_number(&quot;$12.33.21&quot;, locale = locale(grouping_mark = &quot;.&quot;)) ## [1] 123321 parse_double(&quot;12.33&quot;) ## [1] 12.33 parse_double(&quot;12,33&quot;, locale = locale(decimal_mark = &quot;,&quot;)) ## [1] 12.33 str(parse_integer(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;))) ## int [1:3] 1 2 3 5.14 parse_character() parse_character(&quot;Data analytics&quot;, locale = locale(encoding = &quot;Latin1&quot;)) ## [1] &quot;Data analytics&quot; 5.15 parse_guess () 5.16 problems () 5.17 read_delim () 5.18 read_file () 5.19 read_fwf () 5.20 read_lines () 5.21 read_log () 5.22 read_table () 5.23 spec_delim () 5.24 type_convert () 5.25 write_delim () "],
["purrr.html", "6 purrr 6.1 Overview 6.2 Map Family 6.3 Reduce Family", " 6 purrr 6.1 Overview purrr enhances R’s functional programming (FP) toolkit by providing a complete and consistent set of tools for working with functions and vectors. If you’ve never heard of FP before, the best place to start is the family of map() functions which allow you to replace many for loops with code that is both more succinct and easier to read. 6.2 Map Family The complete list of functions within the map family are: map(.x, .f, ...) map_lgl(.x, .f, ...) map_chr(.x, .f, ...) map_int(.x, .f, ...) map_dbl(.x, .f, ...) map_dfr(.x, .f, ..., .id = NULL) map_dfc(.x, .f, ...) walk(.x, .f, ...) Arguments .x: A list or atomic vector .f: A function, formula, or atomic vector If .f is a function, it is used as is If .f is a formula, e.g. ~ .x + 2, it is converted to a function. There are three ways to refer to the arguments: For a single argument function, use . For a two argument function, use .x and .y For more arguments, use ..1, ..2, ..3, etc… 6.2.1 map The map function transforms the input, returning a vector of the same length as the input. map, along with reduce, appear to draw their inspiration from JavaScript. In R, map can be very useful when the programmers wants to use the same function on a list. dplyr has mutate for working with data frames, while purrr specializes in lists. 6.2.1.1 Function Example Lets extract a vector of numbers from an mtcars dataset (mpg). Lets use map to convert that vector into kmpg kmpg &lt;- mpg %&gt;% map(.f = function(x) x * 1.60934) %&gt;% print ## [[1]] ## [1] 33.79614 ## ## [[2]] ## [1] 33.79614 ## ## [[3]] ## [1] 36.69295 ## ## [[4]] ## [1] 34.43988 ## ## [[5]] ## [1] 30.09466 ## ## [[6]] ## [1] 29.12905 ## ## [[7]] ## [1] 23.01356 ## ## [[8]] ## [1] 39.2679 ## ## [[9]] ## [1] 36.69295 ## ## [[10]] ## [1] 30.89933 ## ## [[11]] ## [1] 28.64625 ## ## [[12]] ## [1] 26.39318 ## ## [[13]] ## [1] 27.84158 ## ## [[14]] ## [1] 24.46197 ## ## [[15]] ## [1] 16.73714 ## ## [[16]] ## [1] 16.73714 ## ## [[17]] ## [1] 23.6573 ## ## [[18]] ## [1] 52.14262 ## ## [[19]] ## [1] 48.92394 ## ## [[20]] ## [1] 54.55663 ## ## [[21]] ## [1] 34.60081 ## ## [[22]] ## [1] 24.94477 ## ## [[23]] ## [1] 24.46197 ## ## [[24]] ## [1] 21.40422 ## ## [[25]] ## [1] 30.89933 ## ## [[26]] ## [1] 43.93498 ## ## [[27]] ## [1] 41.84284 ## ## [[28]] ## [1] 48.92394 ## ## [[29]] ## [1] 25.42757 ## ## [[30]] ## [1] 31.704 ## ## [[31]] ## [1] 24.1401 ## ## [[32]] ## [1] 34.43988 data_frame(mpg = c(class(mpg)), kmpg = c(class(kmpg))) %&gt;% kable mpg kmpg numeric list Using map in this instance, returned a list. This may not be preferable in some situations and purrr has built in functions that can return exactly what you are expecting. Our original vector was a numeric vector. We can return a numeric vector using the map_dbl function. Lets re-try the code above using map_dbl. kmpg &lt;- mpg %&gt;% map_dbl(.f = function(x) x * 1.60934) %&gt;% print ## [1] 33.79614 33.79614 36.69295 34.43988 30.09466 29.12905 23.01356 ## [8] 39.26790 36.69295 30.89933 28.64625 26.39318 27.84158 24.46197 ## [15] 16.73714 16.73714 23.65730 52.14262 48.92394 54.55663 34.60081 ## [22] 24.94477 24.46197 21.40422 30.89933 43.93498 41.84284 48.92394 ## [29] 25.42757 31.70400 24.14010 34.43988 data_frame(mpg = c(class(mpg)), kmpg = c(class(kmpg))) %&gt;% kable mpg kmpg numeric numeric As shown, both mpg and kmpg are both numerical vectors. purrr also comes supplies with map_chr, map_dbl, map_dfc (column bind), map_dfr (row bind), map_int, map_lgl. All return vectors except map_dfc and map_dfr which return data frames. 6.2.1.2 Formula Example As stated above, we can also use the map functions with the formula syntax mpg %&gt;% map_dbl(.f = ~ .x * 1.60934) %&gt;% print ## [1] 33.79614 33.79614 36.69295 34.43988 30.09466 29.12905 23.01356 ## [8] 39.26790 36.69295 30.89933 28.64625 26.39318 27.84158 24.46197 ## [15] 16.73714 16.73714 23.65730 52.14262 48.92394 54.55663 34.60081 ## [22] 24.94477 24.46197 21.40422 30.89933 43.93498 41.84284 48.92394 ## [29] 25.42757 31.70400 24.14010 34.43988 6.3 Reduce Family The complete list of functions within the reduce family are: reduce(.x, .f, ..., .init) reduce_right(.x, .f, ..., .init) reduce2(.x, .y, .f, ..., .init) reduce2_right(.x, .y, .f, ..., .init) Arguments .x: A list or atomic vector .f: A 2-argument function. The function will be passed the accumulated value as the first argument and the next value as the second argument. For reduce2(), a 3-argument function. The function will be passed the accumulated value as the first argument, the next value of .x as the second argument, and the next value of .y as the third argument. …: Additional arguments passed on to .f .init: If supplied, will be used as the first value to start the accumulation, rather than using x[[1]]. This is useful if you want to ensure that reduce returns a correct value when .x is empty. If missing, and x is empty, will throw an error .y: For reduce2(), an additional argument that is passed to .f. If init is not set, .y should be 1 element shorter than .x 6.3.1 reduce The reduce function transforms the input into a single value by iteratively applying a binary function. Another function whose inspiration seems to stem from JavaScript. In R, reduce can be useful when you have a list or vector of values that need to be “accumulated” in some form to create a single item. 6.3.1.1 Example Lets pretend that we wanted to create a pipe-delimited string from the row names of our cars data names &lt;- row.names(cars) %&gt;% reduce(.f = function(start, .next) paste(start, .next, sep = &quot;|&quot;)) %&gt;% print ## [1] &quot;Mazda RX4|Mazda RX4 Wag|Datsun 710|Hornet 4 Drive|Hornet Sportabout|Valiant|Duster 360|Merc 240D|Merc 230|Merc 280|Merc 280C|Merc 450SE|Merc 450SL|Merc 450SLC|Cadillac Fleetwood|Lincoln Continental|Chrysler Imperial|Fiat 128|Honda Civic|Toyota Corolla|Toyota Corona|Dodge Challenger|AMC Javelin|Camaro Z28|Pontiac Firebird|Fiat X1-9|Porsche 914-2|Lotus Europa|Ford Pantera L|Ferrari Dino|Maserati Bora|Volvo 142E&quot; "],
["tibble.html", "7 tibble 7.1 How to create tibble? 7.2 tibble-package () 7.3 add_column () 7.4 add_row () 7.5 enframe () 7.6 frame_matrix () 7.7 glimpse () 7.8 is_tibble () 7.9 new_tibble () 7.10 rownames () 7.11 set_tidy_names () 7.12 tbl_sum () 7.13 tibble-options ()", " 7 tibble Tibbles are a modern take on data frames. They keep the features that have stood the test of time, and drop the features that used to be convenient but are now frustrating (i.e. converting character vectors to factors). 7.1 How to create tibble? 7.1.1 as_tibble() You can coerce a data frame to tibble. as_tibble(nycflights13::airlines) ## # A tibble: 16 x 2 ## carrier name ## &lt;chr&gt; &lt;chr&gt; ## 1 9E Endeavor Air Inc. ## 2 AA American Airlines Inc. ## 3 AS Alaska Airlines Inc. ## 4 B6 JetBlue Airways ## 5 DL Delta Air Lines Inc. ## 6 EV ExpressJet Airlines Inc. ## 7 F9 Frontier Airlines Inc. ## 8 FL AirTran Airways Corporation ## 9 HA Hawaiian Airlines Inc. ## 10 MQ Envoy Air ## 11 OO SkyWest Airlines Inc. ## 12 UA United Air Lines Inc. ## 13 US US Airways Inc. ## 14 VX Virgin America ## 15 WN Southwest Airlines Co. ## 16 YV Mesa Airlines Inc. 7.1.2 tibble() You can create a new tibble from individual vectors with tibble(). tibble( a = 1:15, b = a * 2, c = a ^ 2 + b ) ## # A tibble: 15 x 3 ## a b c ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2. 3. ## 2 2 4. 8. ## 3 3 6. 15. ## 4 4 8. 24. ## 5 5 10. 35. ## 6 6 12. 48. ## 7 7 14. 63. ## 8 8 16. 80. ## 9 9 18. 99. ## 10 10 20. 120. ## 11 11 22. 143. ## 12 12 24. 168. ## 13 13 26. 195. ## 14 14 28. 224. ## 15 15 30. 255. 7.1.3 tribble() Another way to create a tibble is with tribble(), short for transposed tibble. tribble() is customised for data entry in code: column headings are defined by formulas (i.e. they start with ~), and entries are separated by commas. This makes it possible to lay out small amounts of data in easy to read form. tribble( ~x, ~y, ~z, #--|--|---- &quot;a&quot;, 2, 3.6, &quot;b&quot;, 1, 8.5 ) ## # A tibble: 2 x 3 ## x y z ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 2. 3.60 ## 2 b 1. 8.50 It’s possible for a tibble to have column names that are not valid R variable names, aka non-syntactic names. tb &lt;- tibble( `:-)` = &quot;smile&quot;, ` ` = &quot;space&quot;, `5000` = &quot;number&quot; ) Reference Cran R Blog R for Data Science 7.2 tibble-package () 7.3 add_column () 7.4 add_row () 7.5 enframe () 7.6 frame_matrix () 7.7 glimpse () 7.8 is_tibble () 7.9 new_tibble () 7.10 rownames () 7.11 set_tidy_names () 7.12 tbl_sum () 7.13 tibble-options () "],
["stringr.html", "8 stringr 8.1 case () 8.2 invert_match () 8.3 modifiers () 8.4 stringr-data () 8.5 str_c () 8.6 str_conv () 8.7 str_count () 8.8 str_detect () 8.9 str_dup () 8.10 str_extract () 8.11 str_flatten () 8.12 str_glue () 8.13 str_length () 8.14 str_locate () 8.15 str_match () 8.16 str_order () 8.17 str_pad () 8.18 str_remove () 8.19 str_replace () 8.20 str_replace_na () 8.21 str_split () 8.22 str_sub () 8.23 str_subset () 8.24 str_trim () 8.25 str_trunc () 8.26 str_view () 8.27 str_wrap () 8.28 word ()", " 8 stringr library(stringr) ###Pattern matching ####str_count Count the number of matches in a string Examples fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pineapple&quot;) str_count(fruit, &quot;a&quot;) ## [1] 1 3 1 1 str_count(fruit, &quot;p&quot;) ## [1] 2 0 1 3 str_count(fruit, &quot;e&quot;) ## [1] 1 0 1 2 str_count(fruit, c(&quot;a&quot;, &quot;b&quot;, &quot;p&quot;, &quot;p&quot;)) ## [1] 1 1 1 3 str_count(c(&quot;a.&quot;, &quot;...&quot;, &quot;.a.a&quot;), &quot;.&quot;) ## [1] 2 3 4 str_count(c(&quot;a.&quot;, &quot;...&quot;, &quot;.a.a&quot;), fixed(&quot;.&quot;)) ## [1] 1 3 2 ####str_detect Detect the presence or absence of a pattern in a string. Examples fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pinapple&quot;) str_detect(fruit, &quot;a&quot;) ## [1] TRUE TRUE TRUE TRUE str_detect(fruit, &quot;^a&quot;) ## [1] TRUE FALSE FALSE FALSE str_detect(fruit, &quot;a$&quot;) ## [1] FALSE TRUE FALSE FALSE str_detect(fruit, &quot;b&quot;) ## [1] FALSE TRUE FALSE FALSE str_detect(fruit, &quot;[aeiou]&quot;) ## [1] TRUE TRUE TRUE TRUE # Also vectorised over pattern str_detect(&quot;aecfg&quot;, letters) ## [1] TRUE FALSE TRUE FALSE TRUE TRUE TRUE FALSE FALSE FALSE FALSE ## [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [23] FALSE FALSE FALSE FALSE ####str_extract Extract matching patterns from a string. Examples: shopping_list &lt;- c(&quot;apples x4&quot;, &quot;bag of flour&quot;, &quot;bag of sugar&quot;, &quot;milk x2&quot;) str_extract(shopping_list, &quot;\\\\d&quot;) ## [1] &quot;4&quot; NA NA &quot;2&quot; str_extract(shopping_list, &quot;[a-z]+&quot;) ## [1] &quot;apples&quot; &quot;bag&quot; &quot;bag&quot; &quot;milk&quot; str_extract(shopping_list, &quot;[a-z]{1,4}&quot;) ## [1] &quot;appl&quot; &quot;bag&quot; &quot;bag&quot; &quot;milk&quot; str_extract(shopping_list, &quot;\\\\b[a-z]{1,4}\\\\b&quot;) ## [1] NA &quot;bag&quot; &quot;bag&quot; &quot;milk&quot; # Extract all matches str_extract_all(shopping_list, &quot;[a-z]+&quot;) ## [[1]] ## [1] &quot;apples&quot; &quot;x&quot; ## ## [[2]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; ## ## [[3]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; ## ## [[4]] ## [1] &quot;milk&quot; &quot;x&quot; str_extract_all(shopping_list, &quot;\\\\b[a-z]+\\\\b&quot;) ## [[1]] ## [1] &quot;apples&quot; ## ## [[2]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; ## ## [[3]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; ## ## [[4]] ## [1] &quot;milk&quot; str_extract_all(shopping_list, &quot;\\\\d&quot;) ## [[1]] ## [1] &quot;4&quot; ## ## [[2]] ## character(0) ## ## [[3]] ## character(0) ## ## [[4]] ## [1] &quot;2&quot; # Simplify results into character matrix str_extract_all(shopping_list, &quot;\\\\b[a-z]+\\\\b&quot;, simplify = TRUE) ## [,1] [,2] [,3] ## [1,] &quot;apples&quot; &quot;&quot; &quot;&quot; ## [2,] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; ## [3,] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; ## [4,] &quot;milk&quot; &quot;&quot; &quot;&quot; str_extract_all(shopping_list, &quot;\\\\d&quot;, simplify = TRUE) ## [,1] ## [1,] &quot;4&quot; ## [2,] &quot;&quot; ## [3,] &quot;&quot; ## [4,] &quot;2&quot; # Extract all words str_extract_all(&quot;This is, suprisingly, a sentence.&quot;, boundary(&quot;word&quot;)) ## [[1]] ## [1] &quot;This&quot; &quot;is&quot; &quot;suprisingly&quot; &quot;a&quot; &quot;sentence&quot; ####str_extract_all str_extract_all(string, pattern, simplify = FALSE) Examples: shopping_list &lt;- c(&quot;apples x4&quot;, &quot;bag of flour&quot;, &quot;bag of sugar&quot;, &quot;milk x2&quot;) str_extract(shopping_list, &quot;\\\\d&quot;) ## [1] &quot;4&quot; NA NA &quot;2&quot; str_extract(shopping_list, &quot;[a-z]+&quot;) ## [1] &quot;apples&quot; &quot;bag&quot; &quot;bag&quot; &quot;milk&quot; str_extract(shopping_list, &quot;[a-z]{1,4}&quot;) ## [1] &quot;appl&quot; &quot;bag&quot; &quot;bag&quot; &quot;milk&quot; str_extract(shopping_list, &quot;\\\\b[a-z]{1,4}\\\\b&quot;) ## [1] NA &quot;bag&quot; &quot;bag&quot; &quot;milk&quot; # Extract all matches str_extract_all(shopping_list, &quot;[a-z]+&quot;) ## [[1]] ## [1] &quot;apples&quot; &quot;x&quot; ## ## [[2]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; ## ## [[3]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; ## ## [[4]] ## [1] &quot;milk&quot; &quot;x&quot; str_extract_all(shopping_list, &quot;\\\\b[a-z]+\\\\b&quot;) ## [[1]] ## [1] &quot;apples&quot; ## ## [[2]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; ## ## [[3]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; ## ## [[4]] ## [1] &quot;milk&quot; str_extract_all(shopping_list, &quot;\\\\d&quot;) ## [[1]] ## [1] &quot;4&quot; ## ## [[2]] ## character(0) ## ## [[3]] ## character(0) ## ## [[4]] ## [1] &quot;2&quot; str_extract_all(shopping_list, &quot;\\\\b[a-z]+\\\\b&quot;, simplify = TRUE) ## [,1] [,2] [,3] ## [1,] &quot;apples&quot; &quot;&quot; &quot;&quot; ## [2,] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; ## [3,] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; ## [4,] &quot;milk&quot; &quot;&quot; &quot;&quot; str_extract_all(shopping_list, &quot;\\\\d&quot;, simplify = TRUE) ## [,1] ## [1,] &quot;4&quot; ## [2,] &quot;&quot; ## [3,] &quot;&quot; ## [4,] &quot;2&quot; str_extract_all(&quot;This is, suprisingly, a sentence.&quot;, boundary(&quot;word&quot;)) ## [[1]] ## [1] &quot;This&quot; &quot;is&quot; &quot;suprisingly&quot; &quot;a&quot; &quot;sentence&quot; ###Locate the position of patterns in a string. ####str_locate(string, pattern) For str_locate, an integer matrix. First column gives start postion of match, and second column gives end position. For str_locate_all a list of integer matrices. Vectorised over string and pattern. If the match is of length 0, (e.g. from a special match like $) end will be one character less than start. Examples str_locate and str_locate_all: fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pineapple&quot;) str_locate(fruit, &quot;$&quot;) ## start end ## [1,] 6 5 ## [2,] 7 6 ## [3,] 5 4 ## [4,] 10 9 str_locate(fruit, &quot;a&quot;) ## start end ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 ## [4,] 5 5 str_locate(fruit, &quot;e&quot;) ## start end ## [1,] 5 5 ## [2,] NA NA ## [3,] 2 2 ## [4,] 4 4 str_locate(fruit, c(&quot;a&quot;, &quot;b&quot;, &quot;p&quot;, &quot;p&quot;)) ## start end ## [1,] 1 1 ## [2,] 1 1 ## [3,] 1 1 ## [4,] 1 1 str_locate_all(fruit, &quot;a&quot;) ## [[1]] ## start end ## [1,] 1 1 ## ## [[2]] ## start end ## [1,] 2 2 ## [2,] 4 4 ## [3,] 6 6 ## ## [[3]] ## start end ## [1,] 3 3 ## ## [[4]] ## start end ## [1,] 5 5 str_locate_all(fruit, &quot;e&quot;) ## [[1]] ## start end ## [1,] 5 5 ## ## [[2]] ## start end ## ## [[3]] ## start end ## [1,] 2 2 ## ## [[4]] ## start end ## [1,] 4 4 ## [2,] 9 9 # Find location of every character str_locate_all(fruit, &quot;&quot;) ## [[1]] ## start end ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 ## [4,] 4 4 ## [5,] 5 5 ## ## [[2]] ## start end ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 ## [4,] 4 4 ## [5,] 5 5 ## [6,] 6 6 ## ## [[3]] ## start end ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 ## [4,] 4 4 ## ## [[4]] ## start end ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 ## [4,] 4 4 ## [5,] 5 5 ## [6,] 6 6 ## [7,] 7 7 ## [8,] 8 8 ## [9,] 9 9 ###Extract matched groups from a string. Vectorised over string and pattern. str_match(string, pattern) str_match_all(string, pattern) For str_match, a character matrix. First column is the complete match, followed by one column for each capture group. For str_match_all, a list of character matrices. Examples: strings &lt;- c(&quot; 219 733 8965&quot;, &quot;329-293-8753 &quot;, &quot;banana&quot;, &quot;595 794 7569&quot;, &quot;387 287 6718&quot;, &quot;apple&quot;, &quot;233.398.9187 &quot;, &quot;482 952 3315&quot;, &quot;239 923 8115 and 842 566 4692&quot;, &quot;Work: 579-499-7527&quot;, &quot;$1000&quot;, &quot;Home: 543.355.3679&quot;) phone &lt;- &quot;([2-9][0-9]{2})[- .]([0-9]{3})[- .]([0-9]{4})&quot; str_extract(strings, phone) ## [1] &quot;219 733 8965&quot; &quot;329-293-8753&quot; NA &quot;595 794 7569&quot; ## [5] &quot;387 287 6718&quot; NA &quot;233.398.9187&quot; &quot;482 952 3315&quot; ## [9] &quot;239 923 8115&quot; &quot;579-499-7527&quot; NA &quot;543.355.3679&quot; str_match(strings, phone) ## [,1] [,2] [,3] [,4] ## [1,] &quot;219 733 8965&quot; &quot;219&quot; &quot;733&quot; &quot;8965&quot; ## [2,] &quot;329-293-8753&quot; &quot;329&quot; &quot;293&quot; &quot;8753&quot; ## [3,] NA NA NA NA ## [4,] &quot;595 794 7569&quot; &quot;595&quot; &quot;794&quot; &quot;7569&quot; ## [5,] &quot;387 287 6718&quot; &quot;387&quot; &quot;287&quot; &quot;6718&quot; ## [6,] NA NA NA NA ## [7,] &quot;233.398.9187&quot; &quot;233&quot; &quot;398&quot; &quot;9187&quot; ## [8,] &quot;482 952 3315&quot; &quot;482&quot; &quot;952&quot; &quot;3315&quot; ## [9,] &quot;239 923 8115&quot; &quot;239&quot; &quot;923&quot; &quot;8115&quot; ## [10,] &quot;579-499-7527&quot; &quot;579&quot; &quot;499&quot; &quot;7527&quot; ## [11,] NA NA NA NA ## [12,] &quot;543.355.3679&quot; &quot;543&quot; &quot;355&quot; &quot;3679&quot; # Extract/match all str_extract_all(strings, phone) ## [[1]] ## [1] &quot;219 733 8965&quot; ## ## [[2]] ## [1] &quot;329-293-8753&quot; ## ## [[3]] ## character(0) ## ## [[4]] ## [1] &quot;595 794 7569&quot; ## ## [[5]] ## [1] &quot;387 287 6718&quot; ## ## [[6]] ## character(0) ## ## [[7]] ## [1] &quot;233.398.9187&quot; ## ## [[8]] ## [1] &quot;482 952 3315&quot; ## ## [[9]] ## [1] &quot;239 923 8115&quot; &quot;842 566 4692&quot; ## ## [[10]] ## [1] &quot;579-499-7527&quot; ## ## [[11]] ## character(0) ## ## [[12]] ## [1] &quot;543.355.3679&quot; str_match_all(strings, phone) ## [[1]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;219 733 8965&quot; &quot;219&quot; &quot;733&quot; &quot;8965&quot; ## ## [[2]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;329-293-8753&quot; &quot;329&quot; &quot;293&quot; &quot;8753&quot; ## ## [[3]] ## [,1] [,2] [,3] [,4] ## ## [[4]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;595 794 7569&quot; &quot;595&quot; &quot;794&quot; &quot;7569&quot; ## ## [[5]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;387 287 6718&quot; &quot;387&quot; &quot;287&quot; &quot;6718&quot; ## ## [[6]] ## [,1] [,2] [,3] [,4] ## ## [[7]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;233.398.9187&quot; &quot;233&quot; &quot;398&quot; &quot;9187&quot; ## ## [[8]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;482 952 3315&quot; &quot;482&quot; &quot;952&quot; &quot;3315&quot; ## ## [[9]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;239 923 8115&quot; &quot;239&quot; &quot;923&quot; &quot;8115&quot; ## [2,] &quot;842 566 4692&quot; &quot;842&quot; &quot;566&quot; &quot;4692&quot; ## ## [[10]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;579-499-7527&quot; &quot;579&quot; &quot;499&quot; &quot;7527&quot; ## ## [[11]] ## [,1] [,2] [,3] [,4] ## ## [[12]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;543.355.3679&quot; &quot;543&quot; &quot;355&quot; &quot;3679&quot; x &lt;- c(&quot;&lt;a&gt; &lt;b&gt;&quot;, &quot;&lt;a&gt; &lt;&gt;&quot;, &quot;&lt;a&gt;&quot;, &quot;&quot;, NA) str_match(x, &quot;&lt;(.*?)&gt; &lt;(.*?)&gt;&quot;) ## [,1] [,2] [,3] ## [1,] &quot;&lt;a&gt; &lt;b&gt;&quot; &quot;a&quot; &quot;b&quot; ## [2,] &quot;&lt;a&gt; &lt;&gt;&quot; &quot;a&quot; &quot;&quot; ## [3,] NA NA NA ## [4,] NA NA NA ## [5,] NA NA NA str_match_all(x, &quot;&lt;(.*?)&gt;&quot;) ## [[1]] ## [,1] [,2] ## [1,] &quot;&lt;a&gt;&quot; &quot;a&quot; ## [2,] &quot;&lt;b&gt;&quot; &quot;b&quot; ## ## [[2]] ## [,1] [,2] ## [1,] &quot;&lt;a&gt;&quot; &quot;a&quot; ## [2,] &quot;&lt;&gt;&quot; &quot;&quot; ## ## [[3]] ## [,1] [,2] ## [1,] &quot;&lt;a&gt;&quot; &quot;a&quot; ## ## [[4]] ## [,1] [,2] ## ## [[5]] ## [,1] [,2] ## [1,] NA NA str_extract(x, &quot;&lt;.*?&gt;&quot;) ## [1] &quot;&lt;a&gt;&quot; &quot;&lt;a&gt;&quot; &quot;&lt;a&gt;&quot; NA NA str_extract_all(x, &quot;&lt;.*?&gt;&quot;) ## [[1]] ## [1] &quot;&lt;a&gt;&quot; &quot;&lt;b&gt;&quot; ## ## [[2]] ## [1] &quot;&lt;a&gt;&quot; &quot;&lt;&gt;&quot; ## ## [[3]] ## [1] &quot;&lt;a&gt;&quot; ## ## [[4]] ## character(0) ## ## [[5]] ## [1] NA 8.1 case () 8.2 invert_match () 8.3 modifiers () 8.4 stringr-data () 8.5 str_c () 8.6 str_conv () 8.7 str_count () 8.8 str_detect () 8.9 str_dup () 8.10 str_extract () 8.11 str_flatten () 8.12 str_glue () 8.13 str_length () 8.14 str_locate () 8.15 str_match () 8.16 str_order () 8.17 str_pad () 8.18 str_remove () 8.19 str_replace () 8.20 str_replace_na () 8.21 str_split () 8.22 str_sub () 8.23 str_subset () 8.24 str_trim () 8.25 str_trunc () 8.26 str_view () 8.27 str_wrap () 8.28 word () "],
["forcats.html", "9 forcats 9.1 as_factor () 9.2 fct_anonv () 9.3 fct_c () 9.4 fct_collapse () 9.5 fct_count () 9.6 fct_drop () 9.7 fct_expand () 9.8 fct_explicit_na () 9.9 fct_inorder () 9.10 fct_lump () 9.11 fct_other () 9.12 fct_recode () 9.13 fct_relabel () 9.14 fct_relevel () 9.15 fct_reorder () 9.16 fct_rev () 9.17 fct_shift () 9.18 fct_shuffle () 9.19 fct_unify () 9.20 fct_unique () 9.21 gss_cat () 9.22 lvls () 9.23 lvls_union ()", " 9 forcats 9.1 as_factor () 9.2 fct_anonv () 9.3 fct_c () 9.4 fct_collapse () 9.5 fct_count () 9.6 fct_drop () 9.7 fct_expand () 9.8 fct_explicit_na () 9.9 fct_inorder () 9.10 fct_lump () 9.11 fct_other () 9.12 fct_recode () 9.13 fct_relabel () 9.14 fct_relevel () 9.15 fct_reorder () 9.16 fct_rev () 9.17 fct_shift () 9.18 fct_shuffle () 9.19 fct_unify () 9.20 fct_unique () 9.21 gss_cat () 9.22 lvls () 9.23 lvls_union () "],
["references.html", "References", " References "]
]
